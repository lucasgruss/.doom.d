#+TITLE:  Configuration for my kitchen sink
#+AUTHOR: Lucas Gruss

* Table of content :TOC:
- [[#introduction][Introduction]]
- [[#doom-stuff][Doom stuff]]
  - [[#initel][init.el]]
  - [[#packagesel][packages.el]]
- [[#theme][Theme]]
  - [[#theme-choice][Theme choice]]
  - [[#modeline][Modeline]]
  - [[#theme-magic][Theme magic]]
- [[#window-management][Window management]]
  - [[#zoom-mode][Zoom mode]]
  - [[#windmove][Windmove]]
  - [[#framemove][Framemove]]
  - [[#windower][Windower]]
- [[#convenience][Convenience]]
  - [[#which-key][Which-key]]
  - [[#deft][Deft]]
- [[#hyperbole][Hyperbole]]
- [[#org-mode][Org mode]]
  - [[#latex][Latex]]
  - [[#calfw][Calfw]]
  - [[#org-sidebar][Org-sidebar]]
  - [[#org-superstar][Org-superstar]]
  - [[#presentation-mode][Presentation mode]]
  - [[#org-noter][Org-noter]]
- [[#pdf][PDF]]
  - [[#pdf-tools][pdf-tools]]
- [[#completions][Completions]]
  - [[#ivy][Ivy]]
  - [[#counsel][Counsel]]
  - [[#ivy-posframe][Ivy-posframe]]
  - [[#ivy-spotify][Ivy-Spotify]]
  - [[#ivy-yasnippet][Ivy-yasnippet]]
  - [[#orderless][Orderless]]
- [[#elfeed][Elfeed]]
- [[#ripgrep][Ripgrep]]
- [[#treemacs][Treemacs]]
- [[#terminal][Terminal]]
- [[#browsing-the-internet][Browsing the internet]]
  - [[#eww][Eww]]
  - [[#w3m][w3m]]
- [[#keybindings][Keybindings]]
  - [[#evil-mode][Evil mode]]
  - [[#misc][Misc]]

* Introduction
This is my configuration file for Doom Emacs. It is a self contained document
with everything needed to set up Doom. Normally you customize Doom by editing
three =.el= files, which are =config.el=, =packages.el= and =init.el=. Thanks to
the =literate= config module, it is possible to have all three in the same org
document and they get automatically tangled in the right place upon saving this
file.

- Doom Emacs ::
  I use Doom Emacs as my configuration framework. I used to have a rather
  lengthy hand-rolled literate configuration file. In a lot of cases, I was
  reinventing the wheel by configuring stuff in a way that was similar to what
  Doom has to offer (or other configuration frameworks for that matter). So I
  just decided that I might as well use a configuration framework and have stuff
  work out of the box. I chose Doom because it enables excellent evil support
  across all the modules (so I don't have to go through the pain of configuring
  everything to get a consistent evil experience). It's also very fast, and has
  a very active community. I want to extend my thanks to Henrik Lissner who is
  the maintainer of the framework, as well as all contributors to the project.

- gcc emacs ::
  I build Emacs from source and I am on the =native-comp= branch. Native
  compilation helps me achieve better performances without headaches, and the
  branch is now stable enough to be used without running into issues. It's most
  likely going to be included in the next release of Emacs (Emacs 28) and I
  would like to extend my thanks to Andrea Corallo who did a fantastic job on
  this feature, as well as all the contributors to this feature.

- The Emacs community ::
  Thank you to all the community in making Emacs such great software. It is
  really hard to express how much Emacs has impacted me. I really like how Emacs
  behaves as a platform and I find it much more pleasant to use a computer
  through Emacs. Thank you to the maintainers across the years, to contributors,
  package developers and users as a whole that make this tool such a polyvalent
  swiss-army kitchen sink.

* Doom stuff
** init.el
This is my doom block. What it contains is pretty self explanatory.

#+begin_src emacs-lisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-

(doom! :input
       ;;chinese
       ;;japanese

       :completion
       company           ; the ultimate code completion backend
       ;;(helm +fuzzy +icons +childframe)              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       ;(ivy +icons +prescient) ; a search engine for love and life

       :ui
       deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       ;;doom-dashboard    ; a nifty splash screen for Emacs
       doom-quit         ; DOOM quit-message prompts when you quit Emacs
       ;;fill-column       ; a `fill-column' indicator
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       ;;hydra
       indent-guides     ; highlighted indent columns
       modeline        ; snazzy, Atom-inspired modeline, plus API
       nav-flash         ; blink the current line after jumping
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup +hacks)   ; tame sudden yet inevitable temporary windows
       ;;ligatures       ; ligatures or substitute text with pretty symbols
       ;;tabs              ; an tab bar for Emacs
       treemacs          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       ;;vc-gutter         ; vcs diff in the fringe
       ;;vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       ;;window-select     ; visually switch windows
       ;;workspaces        ; tab emulation, persistence & separate workspaces
       ;;zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       ;;fold              ; (nigh) universal code folding
       ;;(format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       ;;lispy             ; vim for lisp, for people who don't like vim
       ;;multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of
       ;;rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       ;;word-wrap         ; soft wrapping with language-aware indent

       :emacs
       (dired +icons)   ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       ibuffer         ; interactive buffer management
       vc                ; version-control and Emacs, sitting in a tree

       :term
       eshell            ; a consistent, cross-platform shell (WIP)
       ;;shell             ; a terminal REPL for Emacs
       ;;term              ; terminals in Emacs
       ;;vterm             ; another terminals in Emacs

       :checkers
       ;syntax              ; tasing you for every semicolon you forget
       ;;spell             ; tasing you for misspelling mispelling
       ;;grammar           ; tasing grammar mistake every you make

       :tools
       ;;ansible
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       ;;direnv
       ;;docker
       ;;editorconfig      ; let someone else argue about tabs vs spaces
       ;; ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       (lookup +docsets +dictionnary +offline)               ; navigate your code and its documentation
       (lsp +peek)
       ;;macos             ; MacOS-specific commands
       magit             ; a git porcelain for Emacs
       make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       upload            ; map local to remote projects via ssh/ftp

       :lang
       ;;agda              ; types of types of types of types...
       ;;assembly          ; assembly for fun or debugging
       cc                ; C/C++/Obj-C madness
                                        ;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp        ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;fsharp           ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;go                ; the hipster dialect
       ;;(haskell +dante)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ;
       ;;(java +meghanada) ; the poster child for carpal tunnel syndrome
       ;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       latex             ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ledger            ; an accounting system in Emacs
       lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       matlab
       ;;nim               ; python + lisp at the speed of c
       ;;nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       (org +roam +noter +pretty)               ; organize your plain life in plain text
       ;;perl              ; write code no one else can comprehend
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       (python +lsp)           ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       sh                ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;web               ; the tubes

       :email
       ;;(mu4e +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;irc               ; how neckbeards socialize
       (rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config
       literate
       (default +bindings +smartparens)

       :personal
       exwm
       selectrum)
#+end_src

** packages.el
#+begin_src emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
(package! modus-themes)
(package! theme-magic)
;; (package! explain-pause-mode
;;   :recipe (:host github
;;            :repo "lastquestion/explain-pause-mode"))
(package! windower)
;; (package! svg-tag-mode
;;   :recipe (:host github
;;            :repo "rougier/svg-tag-mode"))
(package! counsel-spotify)
(package! counsel-ffdata)
(package! ivy-youtube)
(package! ivy-yasnippet)
(package! ivy-explorer)
(package! solaire-mode :disable t)
(package! rg)
(package! zoom)
;; (package! hyperbole)
;; (package! calfw
;;   :recipe (:host github
;;            :repo "kiwanami/emacs-calfw"))
;; (package! calfw-org
;;   :recipe (:host github
;;            :repo "kiwanami/emacs-calfw"))
(package! org-tree-slide)
(package! org-superstar)
(package! org-sidebar)
(package! org-emms)
;; (package! org-ref)
(package! ox-report)
;; (package! literate-calc-mode)
;; (package! framemove
;;   :recipe (:host github
;;            :branch "master"
;;            :repo "emacsmirror/emacswiki.org"
;;            :files ("framemove.el")))
;; (package! w3m)
;; (package! pdf-continuous-scroll-mode
;;   :recipe (:host github
;;            :repo "dalanicolai/pdf-continuous-scroll-mode.el"))
(package! emms)
(package! ivy-emms)
;; (package! ytel)
(package! company-prescient)
(package! spotify
  :recipe (:host github
           :repo "danielfm/spotify.el"))
(package! centaur-tabs)
;; (package! minibuffer-statusbar
;;   :recipe (:host github
;;            :repo "akirakyle/minibuffer-statusbar"))
(package! posframe)
(package! fast-scroll
  :recipe (:host github
           :repo "ahungry/fast-scroll"))
                                        ;(package! monkeytype)
(package! hercules)
(package! windresize)
(package! edwina)
(package! scroll-on-jump
  :recipe (:host gitlab
           :repo "ideasman42/emacs-scroll-on-jump"))
(package! good-scroll
  :recipe (:host github
           :repo "io12/good-scroll.el"))
(package! fish-completion
  :recipe (:host gitlab
           :repo "ambrevar/emacs-fish-completion"))
(package! olivetti)
#+end_src

* Theme
** All the icons
#+begin_src emacs-lisp :tangle config.el :results no
(after! all-the-icons
  (add-to-list 'all-the-icons-mode-icon-alist
               '(exwm-mode  all-the-icons-faicon "toggle-on"   :height 1.0 :v-adjust -0.2 :face all-the-icons-green)))
#+end_src

** modus themes
#+begin_src emacs-lisp :tangle config.el
(use-package modus-themes
  :config
   (setq modus-themes-slanted-constructs t)
   (setq modus-themes-bold-constructs t)
   (setq modus-themes-fringes 'subtle) ; {nil,'subtle,'intense})
   (setq modus-themes-mode-line nil) ; {nil,'3d,'moody}
   ;(setq modus-themes-faint-syntax nil)
   (setq modus-themes-intense-hl-line t)
   ;(setq modus-themes-intense-paren-match t)
   ;(setq modus-themes-no-link-underline t)
   (setq modus-themes-prompts 'intense) ; {nil,'subtle,'intense}
   (setq modus-themes-completions 'moderate) ; {nil,'moderate,'opinionated})
   ;(setq modus-themes-intense-standard-completions t)
   (setq modus-themes-diffs nil) ; {nil,'desaturated,'fg-only})
   (setq modus-themes-org-blocks 'greyscale) ; {nil,'greyscale,'rainbow}
   (setq modus-themes-headings '((t . rainbow)))
   (setq modus-themes-variable-pitch-headings nil)
   (setq modus-themes-scale-headings t)
   (setq modus-themes-scale-1 1.1)
   (setq modus-themes-scale-2 1.15)
   (setq modus-themes-scale-3 1.21)
   (setq modus-themes-scale-4 1.27)
   (setq modus-themes-scale-5 1.33))
#+end_src

** Theme choice

#+begin_src emacs-lisp :tangle config.el
(setq! doom-theme 'modus-vivendi)
(setq! doom-font "Iosevka:pixelsize=15")

(defun lg/toggle-transparency ()
  "Toggle the transparency of Emacs on and off"
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter
     nil 'alpha
     (if (eql (cond ((numberp alpha) alpha)
                    ((numberp (cdr alpha)) (cdr alpha))
                    ;; Also handle undocumented (<active> <inactive>) form.
                    ((numberp (cadr alpha)) (cadr alpha)))
              100)
         '(91 . 80) '(100 . 100)))))
#+end_src

** Modeline
*** Doom modeline
#+begin_src emacs-lisp :tangle config.el
(after! doom-modeline
  (progn
    (setq doom-modeline-buffer-file-name-style 'auto
          doom-modeline-bar-width (frame-parameter nil 'left-fringe)
          doom-modeline-height 10
          doom-modeline-icon t
          doom-modeline-major-mode-icon t
          all-the-icons-scale-factor 1
          display-time-format " %H:%M - %Y/%m/%d ")

    ;; redefing segment to show workspace even when tab-bar-mode is disabled
    (doom-modeline-def-segment workspace-name
      "The current workspace name or number.
Requires `eyebrowse-mode' or `tab-bar-mode' to be enabled."
      (when doom-modeline-workspace-name
        (when-let
            ((name (cond
                    ((and (bound-and-true-p eyebrowse-mode)
                          (< 1 (length (eyebrowse--get 'window-configs))))
                     (assq-delete-all 'eyebrowse-mode mode-line-misc-info)
                     (when-let*
                         ((num (eyebrowse--get 'current-slot))
                          (tag (nth 2 (assoc num (eyebrowse--get 'window-configs)))))
                       (if (< 0 (length tag)) tag (int-to-string num))))
                    (t
                     (let* ((current-tab (tab-bar--current-tab))
                            (tab-index (tab-bar--current-tab-index))
                            (explicit-name (alist-get 'explicit-name current-tab))
                            (tab-name (alist-get 'name current-tab)))
                       (if explicit-name tab-name (+ 1 tab-index)))))))
          (propertize (format " %s " name) 'face
                      (if (doom-modeline--active)
                          'doom-modeline-buffer-major-mode
                        'mode-line-inactive)))))
    (display-time-mode +1)))
#+end_src

** Theme magic

In the offchance I am not using emacs for something, then set the same theme
through Xressources.

#+begin_src emacs-lisp :tangle config.el
(use-package! theme-magic
  :config
  (theme-magic-export-theme-mode +1))
#+end_src

** fringes
   #+begin_src emacs-lisp :tangle config.el
(fringe-mode -1)
   #+end_src

* Window management
** Popups
  #+begin_src emacs-lisp :tangle config.el
(set-popup-rules!
    '(("^\\*Completions" :ignore t)
      ("^\\*Local variables\\*$"
       :vslot -1 :slot 1 :size +popup-shrink-to-fit)
      ("^\\*\\(?:[Cc]ompil\\(?:ation\\|e-Log\\)\\|Messages\\)"
       :vslot -2 :size 0.3  :autosave t :quit t :ttl nil)
      ;; ("^\\*\\(?:doom \\|Pp E\\)"  ; transient buffers (no interaction required)
      ;;  :vslot -3 :size +popup-shrink-to-fit :autosave t :select ignore :quit t :ttl 0)
      ;; ("^\\*doom:"  ; editing buffers (interaction required)
      ;;  :vslot -4 :size 0.35 :autosave t :select t :modeline t :quit nil :ttl t)
      ("^\\*doom:\\(?:v?term\\|e?shell\\)-popup"  ; editing buffers (interaction required)
       :ignore t)
      ;;  :vslot -5 :size 0.35 :select t :modeline nil :quit nil :ttl nil)
      ("^\\*\\(?:Wo\\)?Man "
       :vslot -6 :size 0.45 :select t :quit t :ttl 0)
      ("^\\*Calc"
       :vslot -7 :side bottom :size 0.4 :select t :quit nil :ttl 0)
      ("^\\*Customize"
       :slot 2 :side right :size 0.5 :select t :quit nil)
      ("^ \\*undo-tree\\*"
       :slot 2 :side left :size 20 :select t :quit t)
      ;; `help-mode', `helpful-mode'
      ("^\\*[Hh]elp"
      ;;  :slot 2 :vslot -8 :size 0.35 :select t)
      ;; ("^\\*eww\\*"  ; `eww' (and used by dash docsets)
       :vslot -11 :size 0.35 :select t)
      ("^\\*info\\*$"  ; `Info-mode'
       :slot 2 :vslot 2 :size 0.45 :select t)
      ("^\\*Warnings" :vslot 99 :size 0.25)
      ("^\\*Backtrace" :vslot 99 :size 0.4 :quit nil)
      ("^\\*CPU-Profiler-Report "    :side bottom :vslot 100 :slot 1 :height 0.4 :width 0.5 :quit nil)
      ("^\\*Memory-Profiler-Report " :side bottom :vslot 100 :slot 2 :height 0.4 :width 0.5 :quit nil)
      ("^\\*Process List\\*" :side bottom :vslot 101 :size 0.25 :select t :quit t)
      ("^\\*\\(?:Proced\\|timer-list\\|Abbrevs\\|Output\\|Occur\\|unsent mail\\)\\*" :ignore t)))
  #+end_src

** Zoom mode
Zoom is a nice package for window management in emacs. It enlarges the window
that has focus.
#+begin_src emacs-lisp :tangle config.el
(use-package! zoom
  :config
  (map!
   :leader
   (:prefix ("t" . "toggle")
    :desc "Zoom mode" "Z" #'zoom-mode))
  (zoom-mode -1))
#+end_src

** Windmove
#+begin_src emacs-lisp :tangle config.el
(use-package! windmove
  :init
  (map! "s-h" #'windmove-left
        "s-j" #'windmove-down
        "s-k" #'windmove-up
        "s-l" #'windmove-right)
  :config
  (setq! windmove-wrap-around nil
         windmove-window-distance-delta 1))
#+end_src

** Framemove

Framemove extends windmove and allows to move from frame to frame. It makes
switching from screen to screen easier in EXWM.
#+begin_src emacs-lisp :tangle config.el
(use-package! framemove
  :after exwm-randr
  :init
  (load! "framemove.el")
  :config
  (setq framemove-hook-into-windmove t))
#+end_src

** Windower
#+begin_src emacs-lisp :tangle config.el
(use-package! windower
  :init
  (map! "s-H"     #'windower-swap-left
        "s-J"     #'windower-swap-below
        "s-K"     #'windower-swap-above
        "s-L"     #'windower-swap-right
        "s-M-h"   #'windower-move-border-left
        "s-M-j"   #'windower-move-border-below
        "s-M-k"   #'windower-move-border-above
        "s-M-l"   #'windower-move-border-right
        "s-<tab>" #'windower-switch-to-last-buffer
        "s-r"     #'windower-switch-to-last-buffer
        "s-o"     #'windower-toggle-single
        "s-\\"    #'windower-toggle-split))
#+end_src

** Windresize

#+begin_src emacs-lisp :tangle config.el
(use-package windresize)
#+end_src

** Edwina

   #+begin_src emacs-lisp :tangle config.el
(use-package edwina
  :commands (edwina-mode lg/edwina-popup)
  :hook (edwina-mode . lg/edwina-remove-or-restore-buffer-behaviour)
  :init
  (defun lg/edwina-popup ()
    "Dummy function to access edwina-mode-map with Hercules"
    (interactive))
  :config
  (defvar display-buffer-alist-save nil)
  (defvar display-buffer-base-action-save nil)

  (defun lg/edwina-remove-or-restore-buffer-behaviour ()
    "If edwina-mode is active, save and set to nil the following variables:

       - display-buffer-alist
       - display-buffer-base-action

 or restore it if edwina mode is inactive."
    (if edwina-mode
        (progn
          (setq display-buffer-base-action-save display-buffer-base-action)
          (setq display-buffer-base-action '(display-buffer-below-selected))
          (setq display-buffer-alist-save display-buffer-alist)
          (setq display-buffer-alist nil))
      (setq display-buffer-base-action display-buffer-base-action-save)
      (setq display-buffer-alist display-buffer-alist-save)))

  (setq edwina-mode-map (make-sparse-keymap))
  (map! (:map edwina-mode-map
         "k" #'edwina-inc-nmaster
         "j" #'edwina-dec-nmaster
         "h" #'edwina-dec-mfact
         "l" #'edwina-inc-mfact)))
   #+end_src

* Tabs
Tabs are a relatively new feature in emacs. They come in two different flavors,
=tab-bar-mode= and =tab-line-mode=. The first one is a great way to have
different window layouts (what people would usually call workspaces) and the
second is a way to display buffers that have been opened in a window (what
people actually expect from tabs).

The tab-bar, much like the tool bar or the menu bar, is related to the frame.
The tab-line, much like the mode-line or header-line, is exclusive to the
buffer.

** Tab-bar-mode

#+begin_src emacs-lisp :tangle config.el
(use-package! tab-bar
  :init
  (map! :nvi "C-t" #'prot/tab-bar-select-tab-dwim
        "s-<" #'lg/tab-previous-and-hide-maybe
        "s->" #'lg/tab-next-and-hide-maybe
        "s-?" #'lg/tab-bar-mode-toggle
        (:leader
         :prefix ("t" . "toggle/tab")
         :desc "new tab" "n" #'tab-new
         :desc "delete tab" "d" #'tab-close
         :desc "next tab" "j" #'tab-next
         :desc "next tab" "k" #'tab-previous
         :desc "toggle tab-bar mode" "t" #'tab-bar-mode))
  :config
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-new-button "+")
  (setq tab-bar-new-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show t)
  (setq tab-bar-separator nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-truncated)

  (defun prot/tab-bar-select-tab-dwim ()
    "Do-What-I-Mean function for getting to a `tab-bar-mode' tab.
If no other tab exists, create one and switch to it.  If there is
one other tab (so two in total) switch to it without further
questions.  Else use completion to select the tab to switch to."
    (interactive)
    (let ((tabs (mapcar (lambda (tab)
                          (alist-get 'name tab))
                        (tab-bar--tabs-recent))))
      (cond ((eq tabs nil)
             (tab-new))
            ((eq (length tabs) 1)
             (tab-next))
            (t
             (call-interactively #'tab-bar-switch-to-tab)))))

  ;; auto-hide the bar, inspired by https://github.com/ema2159/centaur-tabs/issues/129
  ;; and adapted for the tab-bar
  (defvar tab-bar-timer nil)
  (defun tab-bar-timer-initialize ()
    (setq tab-bar-timer (run-with-timer 3 nil (lambda () (tab-bar-mode -1)))))

  (add-hook 'window-setup-hook 'tab-bar-timer-initialize)

  (defun lg/tab-change-and-hide (arg)
    "Change to next tab and hide"
    (cancel-timer tab-bar-timer)
                                        ;(tab-bar-mode -1)
    (if arg
        (tab-next)
      (tab-previous))
    (tab-bar-mode +1)
    (setq tab-bar-timer (run-with-timer 1 nil (lambda () (tab-bar-mode -1)))))

  (defvar tab-bar-mode-force-display nil)

  (defun lg/tab-bar-mode-toggle ()
    "Toggle the tab bar and don't hide it with tab-change-and-hide"
    (interactive)
    (if tab-bar-mode
        (progn
          (tab-bar-mode -1)
          (setq tab-bar-mode-force-display nil))
      (tab-bar-mode +1)
      (setq tab-bar-mode-force-display t)))

  (defun lg/tab-next-and-hide-maybe ()
    "Show tab-bar, switch to next tab and hide"
    (interactive)
    (if (not tab-bar-mode-force-display)
        (lg/tab-change-and-hide t)
      (tab-next)))

  (defun lg/tab-previous-and-hide-maybe ()
    "Show tab-bar, switch to next tab and hide"
    (interactive)
    (if (not tab-bar-mode-force-display)
        (lg/tab-change-and-hide nil)
      (tab-previous)))

  (tab-bar-mode -1))
#+end_src

** Centaur tabs
#+begin_src emacs-lisp :tangle config.el
(use-package! centaur-tabs
  :init
  (map! :n "gt" #'centaur-tabs-forward
        :n "gT" #'centaur-tabs-backward
        "s-m" #'centaur-tabs-backward
        "s-," #'centaur-tabs-forward
        "s-/" #'centaur-tabs-mode)
  :hook
  (ranger-mode . centaur-tabs-local-mode)
  (calendar-mode . centaur-tabs-local-mode)
  (helpful-mode . centaur-tabs-local-mode)
  (exwm-floating-setup . centaur-tabs-local-mode)
  :config
  (setq! centaur-tabs-style "bar"
         centaur-tabs-set-modified-marker t
         centaur-tabs-set-icons t
         centaur-tabs-gray-out-icons t
         centaur-tabs-set-bar 'under
         centaur-tabs-show-navigation-buttons t
         centaur-tabs-height 25
         centaur-tabs-cycle-scope 'tabs
         centaur-tabs-plain-icons nil
         centaur-tabs-label-fixed-length 20
         uniquify-separator "/")

(define-minor-mode centaur-tabs-local-mode
  "Toggle local display of the tab bar.
With prefix argument ARG, turn on if positive, otherwise off.
Returns non-nil if the new state is enabled.
When turned on, if a local header line is shown, it is hidden to show
the tab bar.  The tab bar is locally hidden otherwise.  When turned
off, if a local header line is hidden or the tab bar is locally
hidden, it is shown again.  Signal an error if Centaur-Tabs mode is off."
  :group 'centaur-tabs
  :global nil
  (if (centaur-tabs-mode-on-p)
    (progn
;;; ON
      (if centaur-tabs-local-mode
          (if (and (local-variable-p centaur-tabs-display-line-format)
                   (eval centaur-tabs-display-line-format))

              ;; A local header line exists, hide it to show the tab bar.
              (progn
                ;; Fail in case of an inconsistency because another local
                ;; header line is already hidden.
                (when (local-variable-p 'centaur-tabs--local-hlf)
                  (error "Another local header line is already hidden"))
                (set (make-local-variable 'centaur-tabs--local-hlf)
                     (eval centaur-tabs-display-line-format))
                (kill-local-variable centaur-tabs-display-line-format))
            ;; Otherwise hide the tab bar in this buffer.
            (set centaur-tabs-display-line-format nil))
;;; OFF
        (if (local-variable-p 'centaur-tabs--local-hlf)
	    ;; A local header line is hidden, show it again.
	(progn
	  (set centaur-tabs-display-line-format centaur-tabs--local-hlf)
	  (kill-local-variable 'centaur-tabs--local-hlf))
      ;; The tab bar is locally hidden, show it again.
      (kill-local-variable centaur-tabs-display-line-format))))
    (message "Centaur-Tabs mode must be enabled")))

  (defun centaur-tabs-buffer-groups ()
    "`centaur-tabs-buffer-groups' control buffers' group rules.
Group centaur-tabs with mode if buffer is derived from `eshell-mode'
`emacs-lisp-mode' `dired-mode' `org-mode' `magit-mode'.
All buffer name start with * will group to \"Emacs\".
Other buffer group by `centaur-tabs-get-group-name' with project name."
    (list
     (cond
      ;; ((and (derived-mode-p 'exwm-mode)
      ;;       exwm-firefox-evil-mode)
      ;;       "Firefox")
      ((derived-mode-p 'matlab-mode)
       "Matlab")
      ((or (derived-mode-p 'exwm-mode)
           (string-equal "*EXWM" (substring (buffer-name) 0 4)))
       "EXWM")
      ((derived-mode-p 'eww-mode)
       "eww")
      ((or (string-equal "*" (substring (buffer-name) 0 1))
           (memq major-mode '(magit-process-mode
                              magit-status-mode
                              magit-diff-mode
                              magit-log-mode
                              magit-file-mode
                              magit-blob-mode
                              magit-blame-mode
                              )))
       "Emacs")
      ((derived-mode-p 'eshell-mode)
       "EShell")
      ((derived-mode-p 'emacs-lisp-mode)
       "Elisp")
      ((derived-mode-p 'dired-mode)
       "Dired")
      ((memq major-mode '(org-mode org-agenda-mode diary-mode))
       "OrgMode")
      (t
       (centaur-tabs-get-group-name (current-buffer))))))

  ;; ;; Natural Tab Close
  ;; (defun centaur-tabs-do-close (event)
  ;;   "Given a mouse EVENT, close the tab at the mouse point."
  ;;   (interactive "e")
  ;;   (let ((window (posn-window (event-start event))))
  ;;     (with-selected-window window
  ;;       (select-window window)
  ;;       (centaur-tabs-buffer-select-tab `,(centaur-tabs-get-tab-from-event event))
  ;;       (let* ((buffer     (window-buffer window))
  ;;              (window-num (length (get-buffer-window-list buffer))))
  ;;         (if (> window-num 1)
  ;;             (delete-window window)
  ;;           (centaur-tabs-buffer-close-tab `,(centaur-tabs-get-tab-from-event event)))))))

  ;; (defun centaur-tabs-backward--button (event)
  ;;   "Same as centaur-tabs-backward, but changing window to EVENT source."
  ;;   (interactive "e")
  ;;   (select-window (posn-window (event-start event)))
  ;;   (centaur-tabs-backward-group))

  ;; (defun centaur-tabs-forward--button (event)
  ;;   "Same as centaur-tabs-forward, but changing window to EVENT source."
  ;;   (interactive "e")
  ;;   (select-window (posn-window (event-start event)))
  ;;   (centaur-tabs-forward-group))

  (centaur-tabs-mode +1))
#+end_src

#+RESULTS:
: t

* Convenience
#+begin_src emacs-lisp :tangle config.el
(explain-pause-mode -1)
(server-start)
(load! "private.el") ; credentials and private info
(setq! org-directory "~/org/"
       display-line-numbers-type `relative
       window-min-height 1
       idle-update-delay 0.2
       x-select-enable-primary t
       select-enable-clipboard t
       x-select-enable-clipboard-manager t)

(defun lg/kill-this-buffer ()
  "Kill the current buffer without confirmation"
  (interactive)
  (kill-buffer (current-buffer)))
#+end_src

** Which-key
Which key is one of the killer features for using emacs, it's good to discover
commands and also to not worry about remembering keybindings. I have nothing but
praise for this package *but* the way Doom Emacs sets it makes it pop too
slowly. I want it to appear almost instantaneously.

#+begin_src emacs-lisp :tangle config.el
(after! which-key
  ;; which-key-idle-delay must be set before enabling the mode
  ;; so we disable it, set the variable and re-enable it
  (which-key-mode -1)
  (setq! which-key-idle-delay 0.7)
  (which-key-mode +1))
#+end_src

** Deft
#+BEGIN_SRC emacs-lisp :tangle config.el
(setq deft-directory "~/org")
#+END_SRC

** Fast scroll mode
#+begin_src emacs-lisp :tangle config.el
(use-package fast-scroll
  :config
  (fast-scroll-mode +1))
#+end_src

** Scroll on jump
  #+begin_src emacs-lisp :tangle config.el
(use-package scroll-on-jump
  :after evil
  :config
  (scroll-on-jump-advice-add evil-undo)
  (scroll-on-jump-advice-add evil-redo)
  (scroll-on-jump-advice-add evil-jump-item)
  (scroll-on-jump-advice-add evil-jump-forward)
  (scroll-on-jump-advice-add evil-jump-backward)
  (scroll-on-jump-advice-add evil-ex-search-next)
  (scroll-on-jump-advice-add evil-ex-search-previous)
  (scroll-on-jump-advice-add evil-forward-paragraph)
  (scroll-on-jump-advice-add evil-backward-paragraph)
  (setq scroll-on-jump-duration 0.2))
  #+end_src

** good scroll
   #+begin_src emacs-lisp :tangle config.el
   (use-package good-scroll
     :config
     (good-scroll-mode +1))
   #+end_src

* Mouse support
#+begin_src emacs-lisp :tangle config.el
;;; found at https://tsdh.wordpress.com/2015/03/03/swapping-emacs-windows-using-dragndrop/
(defun th/swap-window-buffers-by-dnd (drag-event)
  "Swaps the buffers displayed in the DRAG-EVENT's start and end
window."
  (interactive "e")
  (let ((start-win (cl-caadr drag-event))
        (end-win   (cl-caaddr drag-event)))
    (when (and (windowp start-win)
               (windowp end-win)
               (not (eq start-win end-win))
               (not (memq (minibuffer-window)
                          (list start-win end-win))))
      (let ((bs (window-buffer start-win))
            (be (window-buffer end-win)))
        (unless (eq bs be)
          (set-window-buffer start-win be)
          (set-window-buffer end-win bs))))))

(map! "<mode-line> <s-drag-mouse-1>" #'th/swap-window-buffers-by-dnd
      "<mode-line> <double-mouse-1>" #'windower-toggle-single
      "<mode-line> <mouse-3>" nil
      "<mode-line> <mouse-2>" #'mouse-delete-window)

(use-package! strokes
  :if window-system
  :config
  (map! "<mouse-8>" #'strokes-do-stroke
        "<S-down-mouse-1>" #'strokes-do-stroke
        "<s-down-mouse-1>" #'strokes-do-stroke)
  (setq! strokes-file "~/.doom.d/strokes")
  (setq! strokes-use-strokes-buffer nil)
  (strokes-mode +1))
      #+end_src

* Hyperbole
Hyperbole is basically hypertext everywhere. Hyperbole understands context and
can call the appropriate action on a piece of text.

#+begin_src emacs-lisp :tangle config.el
(use-package! hyperbole)
#+end_src

* Org mode
** Latex

#+begin_src emacs-lisp :tangle config.el
;; (after! org
;;   (add-to-list 'org-latex-classes '("lettre" "\\documentclass[11pt]{lettre}
;; \\usepackage[utf8]{inputenc}
;; \\usepackage[T1]{fontenc}
;; \\usepackage{lmodern}
;; \\usepackage{eurosym}
;; \\usepackage[french]{babel}"
;;                                     ("\\section{%s}" . "\\section*{%s}")
;;                                     ("\\subsection{%s}" . "\\subsection*{%s}")
;;                                     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
;;                                     ("\\paragraph{%s}" . "\\paragraph*{%s}")
;;                                     ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src

** Calfw

#+begin_src emacs-lisp :tangle no
(use-package! calfw
  :after org)
(use-package! calfw-org
  :after calfw)
#+end_src

** Org-sidebar

#+begin_src emacs-lisp :tangle no
(use-package! org-sidebar
  :after org)
#+end_src

** Org-superstar

Pretty org bullet.
#+begin_src emacs-lisp :tangle config.el
(use-package! org-superstar              ; supersedes `org-bullets'
  :after org
  :config
  (setq org-superstar-remove-leading-stars t)
  (setq org-superstar-headline-bullets-list
        '("🞛" "◉" "○" "▷"))
  (setq org-superstar-item-bullet-alist
        '((?+ . ?•)
          (?* . ?➤)
          (?- . ?–)))
  (org-superstar-mode 1))
#+end_src

** Presentation mode

#+begin_src emacs-lisp :tangle config.el
(use-package! org-tree-slide
  :after org
  :commands prot/org-presentation-mode
  :init
  (map! (:leader
         (:prefix ("t" . "toggle")
          :desc "Org presentation mode" "P" #'prot/org-presentation-mode)))
  :config
  (setq org-tree-slide-breadcrumbs nil)
  (setq org-tree-slide-header nil)
  (setq org-tree-slide-slide-in-effect nil)
  (setq org-tree-slide-heading-emphasis nil)
  (setq org-tree-slide-cursor-init t)
  (setq org-tree-slide-modeline-display nil)
  (setq org-tree-slide-skip-done nil)
  (setq org-tree-slide-skip-comments t)
  (setq org-tree-slide-fold-subtrees-skipped t)
  (setq org-tree-slide-skip-outline-level 2)
  (setq org-tree-slide-never-touch-face t)
  (setq org-tree-slide-activate-message
        (propertize "Presentation mode ON" 'face 'success))
  (setq org-tree-slide-deactivate-message
        (propertize "Presentation mode OFF" 'face 'error))

  (define-minor-mode prot/org-presentation-mode
    "Parameters for plain text presentations with `org-mode'."
    :init-value nil
    :global nil
    (if prot/org-presentation-mode
        (progn
          (unless (eq major-mode 'org-mode)
            (user-error "Not in an Org buffer"))
          (org-tree-slide-mode 1)
          (writeroom-mode 1)
          (org-superstar-mode 1)
          (setq-local display-line-numbers nil)
          (org-indent-mode 1))
      (org-tree-slide-mode -1)
      (writeroom-mode -1)
      (org-superstar-mode -1)
      (setq-local display-line-numbers 'relative)
      (org-indent-mode -1)))

  :bind (("C-c P" . prot/org-presentation-mode)
         :map org-tree-slide-mode-map
         ("C-h" . org-tree-slide-display-header-toggle)
         ("C-l" . org-tree-slide-display-header-toggle)
         ("C-j" . org-tree-slide-move-next-tree)
         ("C-k" . org-tree-slide-move-previous-tree)))
#+end_src

** Org-noter
#+begin_src emacs-lisp :tangle config.el
(use-package! org-noter
  :defer t
  :preface
  ;; Allow the user to preempt this and set the document search path
  ;; If not set then use `org-directory'
  (defvar org-noter-notes-search-path nil)
  :config
  (unless org-noter-notes-search-path
    (setq org-noter-notes-search-path (list org-directory)))
  (setq org-noter-auto-save-last-location t
        org-noter-separate-notes-from-heading t
        org-noter-always-create-frame nil)
  (map!
   (:after (org-noter)
    :map pdf-view-mode-map
    :n "i" #'org-noter-insert-note)))
;; (after! org-noter
;;   (progn
;;     (setq org-noter-always-create-frame nil)
;;     (map!
;;      (:after (org-noter)
;;       :map pdf-view-mode-map
;;       :n "i" #'org-noter-insert-note))))
#+end_src

** Literal calc mode
#+begin_src emacs-lisp :tangle config.el
(use-package! literate-calc-mode
  :after org
  :config
  (literate-calc-minor-mode -1))
#+end_src

* PDF
** pdf-tools
#+begin_src emacs-lisp :tangle config.el
(setq pdf-view-midnight-colors '("#ffffff" . "#000000"))
#+end_src

** Continuous scrolling
#+begin_src emacs-lisp :tangle yes
(use-package! pdf-continuous-scroll-mode
  :after pdf-tools
  :init
  (setq pdf-continuous-scroll-mode-map (make-sparse-keymap))
  ;; (map!
  ;;  (:map pdf-view-mode-map
  ;;   :n "j" #'pdf-continuous-scroll-forward
  ;;   :n "k" #'pdf-continuous-scroll-backward))
   (map!
   (:map pdf-view-mode-map
    :n "j" #'evil-collection-pdf-view-next-line-or-next-page
    :n "k" #'evil-collection-pdf-view-previous-line-or-previous-page))
  )
#+end_src

* Completions
** Ivy

#+begin_src emacs-lisp :tangle config.el
(after! ivy
  (progn
    (setq ivy-re-builders-alist
          '((counsel-ffdata-firefox-history . +ivy-prescient-non-fuzzy)
            (counsel-ffdata-firefox-bookmarks . +ivy-prescient-non-fuzzy)
            (swiper . +ivy-prescient-non-fuzzy)
            (t . ivy-prescient-re-builder)))
    (setq ivy-fixed-height-minibuffer nil
          ivy-add-newline-after-prompt nil)))
#+end_src

** Counsel

#+begin_src emacs-lisp :tangle config.el
(after! counsel
  (progn (map! "M-<tab>" #'counsel-switch-buffer
               (:leader
                (:prefix ("b" . "buffer") "b"
                 #'counsel-switch-buffer "o"
                 #'counsel-switch-buffer-other-window "C-b"
                 #'counsel-switch-buffer-other-window)))))
#+end_src

** Counsel-ffdata
This package allows you to access your history and bookmarks from emacs, how awesome is that ?
#+begin_src emacs-lisp :tangle yes
(use-package! counsel-ffdata
  :commands (counsel-ffdata-firefox-history
             counsel-ffdata-firefox-bookmarks)
  :init
  (map! (:leader
         (:prefix ("s" . "search")
          :desc "Firefox history"   "h" #'counsel-ffdata-firefox-history
          :desc "Firefox bookmarks" "B" #'counsel-ffdata-firefox-bookmarks))))
#+end_src

** Company-prescient
#+begin_src emacs-lisp :tangle yes
(use-package! company-prescient
  :after company
  :config
  (company-prescient-mode))
#+end_src

* Ivy-posframe

#+BEGIN_SRC emacs-lisp :tangle config.el
(after! ivy-posframe
  (progn
    (setq ivy-posframe-border-width 1)
    (setq ivy-posframe-parameters nil)
    (when (featurep! :personal exwm)
      (ivy-posframe-mode -1))))
#+END_SRC

** Ivy-youtube
#+begin_src emacs-lisp :tangle config.el
(use-package! ivy-youtube
  :config
  (map! :leader
        (:prefix ("s" . "search")
         "y" #'ivy-youtube))
  (setq ivy-youtube-play-at "/usr/bin/mpv"))
#+end_src

** Ivy-yasnippet

Snippets are cool, but being able to narrow, preview and discover snippets is
even cooler !

#+begin_src emacs-lisp :tangle config.el
(use-package! ivy-yasnippet
  :init
  (map! (:leader
         (:prefix ("i" . "insert")
          :desc "Snippet" "s" #'ivy-yasnippet))))
#+end_src
** Ivy-Spotify

#+begin_src emacs-lisp :tangle config.el
(use-package! counsel-spotify
  :commands
  (counsel-spotify-next
   counsel-spotify-previous
   counsel-spotify-toggle-play-pause
   counsel-spotify-search-album
   counsel-spotify-search-track
   counsel-spotify-search-artist
   counsel-spotify-search-playlist)
  :init
  (defvar counsel-spotify-map (make-sparse-keymap))
  (map! (:leader
         (:prefix ("a" . "audio")
          "a"  #'counsel-spotify-toggle-play-pause
          "n"  #'counsel-spotify-next
          "p"  #'counsel-spotify-previous
          "j"  #'counsel-spotify-next
          "k"  #'counsel-spotify-previous
          "s"  nil
          "sA" #'counsel-spotify-search-album
          "sa" #'counsel-spotify-search-artist
          "st" #'counsel-spotify-search-track
          "sp" #'counsel-spotify-search-playlist)))
  :config
  (cl-defmethod counsel-spotify-do-play ((backend counsel-spotify-linux-backend) (something (eql nil)))
    nil))
#+end_src

** Ivy-emms
#+begin_src emacs-lisp :tangle config.el
(use-package! ivy-emms
  :after emms)
#+end_src

Emms is a huge package that helps you manage your media files like movies,
music, playlists and streams. You need an external player to play the media
since Emacs is not capable of such feature. My player of choice is =mpv=, along
with youtube-dl for content hosted on youtube.

** Emms
*** General configuration

#+begin_src emacs-lisp :tangle config.el
(use-package! emms
  :commands (emms-streams)
  :init
  (setq! emms-source-file-default-directory "~/Musique/"
         emms-streams-file "~/.doom.d/emms/streams.emms"
         emms-playlist-buffer-name "*Music*"
         emms-info-asynchronously t ; update tags asynchronously
         emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
  (map!
   (:map emms-playlist-mode-map
    :n "q" #'emms-playlist-mode-bury-buffer)
   (:leader
         (:prefix ("a" . "audio")
          "e" nil
          "es" #'emms-stop
          "ee" #'emms-pause
          "eS" #'emms-shuffle
          "ea" #'emms-show-all
          :desc "radio / streams" "r" #'emms-streams
          )))
  :config
  (emms-all)
  (emms-default-players))
#+end_src

*** Streams
Here is the file that contains all the streams that I listen to (radios), all
defined here and tangled to the right file.
#+begin_src emacs-lisp :tangle emms/streams.emms
;;; This is an EMMS playlist file
;; This includes the built-in list of streams which come with Emms by
;; default. Emms has no affiliation of any kind with the streaming
;; audio stations listed below, nor is this an endorsement of these
;; stations. Instead, this is a collection of stations submitted to
;; the project over the years by people who enjoy Emms. We hope you
;; will enjoy them too.

((*track* (type . streamlist) (name . "http://www.somafm.com/beatblender.pls") (metadata "SomaFM: Beatblender" "http://www.somafm.com/beatblender.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://www.somafm.com/secretagent.pls") (metadata "SomaFM: Secret Agent" "http://www.somafm.com/secretagent.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://www.somafm.com/groovesalad.pls") (metadata "SomaFM: Groove Salad" "http://www.somafm.com/groovesalad.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://www.somafm.com/dronezone.pls") (metadata "SomaFM: Drone Zone" "http://www.somafm.com/dronezone.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://www.somafm.com/tagstrance.pls") (metadata "SomaFM: Tag's Trance" "http://www.somafm.com/tagstrance.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://www.somafm.com/indiepop.pls") (metadata "SomaFM: Indie Pop Rocks" "http://www.somafm.com/indiepop.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://www.somafm.com/doomed.pls") (metadata "SomaFM: Doomed" "http://www.somafm.com/doomed.pls" 1 streamlist))
(*track* (type . url) (name . "http://listen.radionomy.com:80/-PHILOSOMATIKAPROGRESSIVE-") (metadata "P H I L O S O M A T I K A - Progressive Psytrance" "http://listen.radionomy.com:80/-PHILOSOMATIKAPROGRESSIVE-" 1 url))
(*track* (type . streamlist) (name . "http://www.bassdrive.com/BassDrive.m3u") (metadata "Drum and Bass Radio, BassDrive" "http://www.bassdrive.com/BassDrive.m3u" 1 streamlist))
(*track* (type . streamlist) (name . "http://www.ibiblio.org/wcpe/wcpe.pls") (metadata "WCPE, Classical Music" "http://www.ibiblio.org/wcpe/wcpe.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://stream.nute.net/kohina/stream.ogg.m3u") (metadata "Kohina - Old school game and demo music" "http://stream.nute.net/kohina/stream.ogg.m3u" 1 streamlist))
(*track* (type . streamlist) (name . "http://privat.is-by.us:8000/necta192.mp3.m3u") (metadata "Nectarine, Demoscene Radio, DE Continuum's relay 192 mp3" "http://privat.is-by.us:8000/necta192.mp3.m3u" 1 streamlist))
(*track* (type . streamlist) (name . "http://nectarine.from-de.com/necta192.m3u") (metadata "Nectarine, Demoscene Radio, DE stream (High Bitrate)" "http://nectarine.from-de.com/necta192.m3u" 1 streamlist))
(*track* (type . streamlist) (name . "http://www.wfmu.org/wfmu.pls") (metadata "WFMU, Freeform radio" "http://www.wfmu.org/wfmu.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://wfmu.org/wfmu_rock.pls") (metadata "WFMU, Rock'n'Soul Ichiban!" "http://www.wfmu.org/wfmu.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://wfmu.org/wfmu_drummer.pls") (metadata "WFMU, Give the Drummer Radio" "http://www.wfmu.org/wfmu.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://wfmu.org/wfmu_sheena.pls") (metadata "WFMU, Sheena's Jungle Room" "http://www.wfmu.org/wfmu.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://nyc01.egihosting.com:6232/listen.pls") (metadata "WBCR-LP - Berkshire Community Radio" "http://nyc01.egihosting.com:6232/listen.pls" 1 streamlist))
(*track* (type . streamlist) (name . "http://199.244.85.125:8000/wxhq1") (metadata "WXHQ-LP - Newport Radio" "http://199.244.85.125:8000/wxhq1" 1 streamlist))
(*track (type . url) (name . "http://direct.franceinter.fr/live/franceinter-lofi.mp3"))
(*track (type . url) (name . "http://direct.franceinter.fr/live/franceinter-midfi.mp3")))
#+end_src

* Video
Mpv helper functions
#+BEGIN_SRC elisp :tangle config.el
(defun mpv-v-open (url)
  "Watch a video from URL in MPV"
  (async-shell-command (format "mpv %s" url)
                       (format "*mpv %s*" url))
  (switch-to-buffer-other-window (format "*mpv %s*" url)))

(defun mpv-a-open (url)
  "Listen to a video from URL in MPV"
  (async-shell-command (format "mpv %s --no-video" url)
                       (format "*mpv %s*" url))
  (switch-to-buffer-other-window (format "*mpv %s*" url)))

;; (defun mpv-a-open (url)
;;   "Listen to a video from URL in MPV"
;;   (start-process "*mpv*"
;;                  (format "*mpv %s*" url)
;;                  "mpv"
;;                  "--no-video"
;;                  url
;;                  ;(format "%s --no-video" url)
;;                  )
;;   (switch-to-buffer-other-window (format "*mpv %s*" url)))
#+END_SRC

* ytel
Ytel is a youtube frontend for Emacs. It is a rather new tool as of writing
these lines. It uses the invidious api (calling it through =curl=), and an
instance of the API has to be chosen. Instances might come and go, so it might
be necessary to check [[github:iv-org/invidious/wiki/Invidious-Instances][the available instances]].

#+begin_src emacs-lisp :tangle config.el
(use-package! ytel
  :commands (ytel)
  :hook (ytel-mode . (lambda () (interactive) (evil-snipe-local-mode -1)))
  :init
  (map! (:leader
         (:prefix ("o" . "open")
          :desc "ytel (youtube client)"  "y" #'ytel)))
  (evil-define-key 'normal ytel-mode-map
    "q" #'ytel-quit
    "v" #'ytel-watch
    "a" #'ytel-listen
    "J" #'ytel-search-next-page
    "K" #'ytel-search-next-page
    "s" #'ytel-search
    "Y" #'ytel-yank-channel-feed)
  :config
  (defun ytel-watch ()
    "Stream video at point in mpv."
    (interactive)
    (let* ((video (ytel-get-current-video))
           (id    (ytel-video-id video))
           (video-api-url (mpv-v-open (concat "https://invidio.us/watch?v=" id))))))

  (defun ytel-listen ()
    "Stream video at point in mpv."
    (interactive)
    (let* ((video (ytel-get-current-video))
           (id    (ytel-video-id video))
           (video-api-url (mpv-a-open (concat "https://invidio.us/watch?v=" id))))))

  (defun ytel-yank-channel-feed (&optional arg)
    "Yank channel's Invidious RSS feed for the current video at point.
          If ARG is given, format it as a Youtube RSS feed."
    (interactive "P")
    (let* ((author (ytel-video-author (ytel-get-current-video)))
           (authorId (ytel-video-authorId (ytel-get-current-video)))
           (url (if arg
                    (concat "https://invidio.us/feed/channel/" authorId)
                  (concat "https://www.youtube.com/feeds/videos.xml?channel_id=" authorId))))
      (kill-new url)
      (message "Copied RSS feed for: %s -- %s" author url)))

  (setq! ytel-invidious-api-url "https://invidious.snopyta.org")
  ;; (setq! ytel-invidious-api-url "https://invidious.fdn.fr")
  ;; (setq! ytel-invidious-api-url "https://invidious.us")
  ;; (setq! ytel-invidious-api-url "https://yewtu.be")
  ;; (setq! ytel-invidious-api-url "https://tube.connect.cafe")
  )
#+end_src

* Elfeed

#+begin_src emacs-lisp :tangle config.el
(after! elfeed
  (progn
    (defun elfeed-view-mpv (&optional use-generic-p)
      "Youtube-feed link"
      (interactive "P")
      (let ((entries (elfeed-search-selected)))
        (cl-loop for entry in entries
	         do (elfeed-untag entry 'unread)
	         when (elfeed-entry-link entry)
	         do (mpv-v-open it))
        (mapc #'elfeed-search-update-entry entries)
        (unless (use-region-p) (forward-line))))

    (defun elfeed-listen-mpv (&optional use-generic-p)
      "Youtube-feed link"
      (interactive "P")
      (let ((entries (elfeed-search-selected)))
        (cl-loop for entry in entries
	         do (elfeed-untag entry 'unread)
	         when (elfeed-entry-link entry)
	         do (mpv-a-open it))
        (mapc #'elfeed-search-update-entry entries)
        (unless (use-region-p) (forward-line))))

    ;; (evil-define-key 'normal elfeed-search-mode-map (kbd "v") 'elfeed-view-mpv)
    ;; (evil-define-key 'normal elfeed-search-mode-map (kbd "a") 'elfeed-listen-mpv)

    (map!
     (:map elfeed-search-mode-map
      :n "v" #'elfeed-view-mpv
      :n "a" #'elfeed-listen-mpv)
     (:map elfeed-show-mode-map
      :n "v" #'elfeed-view-mpv
      :n "a" #'elfeed-listen-mpv)
     (:leader
      (:prefix ("o" . "open")
       :desc "El[f]eed"         "f" #'elfeed
       :desc "El[F]eed update"  "F" #'elfeed-update)))))
#+end_src

* Ripgrep

#+begin_src emacs-lisp :tangle config.el
(use-package! rg)
#+end_src

* Treemacs

#+begin_src emacs-lisp :tangle config.el
(when (featurep! :ui treemacs)
  (map! (:leader
         (:prefix ("t" . "toggle")
          :desc "Treemacs" "T" #'treemacs)))
  (setq treemacs-width 20))
#+end_src

* Terminal
#+begin_src emacs-lisp :tangle config.el
(setq vterm-module-cmake-args "-DUSE_SYSTEM_LIBVTERM=no")
#+end_src
* SVG tags
#+begin_src emacs-lisp :tangle config.el
(use-package! svg-tag-mode
  :config
  (setq! svg-tag-vertical-offset -10))
#+end_src
* Browsing the internet
** Eww

EWW stands for the Emacs Web Wowser, and it is a web browser written in emacs
lisp. It relies on =shr= (simple html renderer), and is only capable of
rendering /you guessed it/ : html. I find myself using it more and more, as it
is really lightweight, and is a really nice interface to read online
documentation, as you can easily copy and paste the snippets to your project.

#+begin_src emacs-lisp :tangle config.el
(use-package! eww
  :commands (eww)
  :init
  (map! (:leader
         :prefix ("o" . "open")
         :desc "eww" "w" #'eww)
        (:map eww-mode-map
         "v" #'eww-mpv-video-at-point
         "a" #'eww-mpv-audio-at-point
         "C-j" #'eww-next-url
         "C-k" #'eww-previous-url))
  :config
  (defun eww-mpv-video-at-point ()
    "View video in url at point in mpv"
    (interactive)
    (mpv-v-open (thing-at-point 'url)))

  (defun eww-mpv-audio-at-point ()
    (interactive)
    "View video in url at point in mpv"
    (mpv-a-open (thing-at-point 'url))))
#+end_src

* Keybindings
** Evil mode
#+begin_src emacs-lisp :tangle config.el
(after! evil
  (map! :n
        "C-e" #'end-of-line))
#+end_src

** Misc
#+begin_src emacs-lisp :tangle config.el
(map! "M-j" #'drag-stuff-down
      "M-k" #'drag-stuff-up
      (:leader
       :desc "Control-x" "x" ctl-x-map
       (:prefix ("f" . "file")
        "o"   #'find-file-other-window
        "C-f" #'find-file-other-window)
       (:prefix ("o" . "open")
        :desc "Spotify" "s" #'lg/run-or-raise-or-dismiss-spotify
        :desc "Firefox" "i" #'lg/run-or-raise-or-dismiss-firefox))
      (:n "gss" #'avy-goto-char-timer))
#+end_src
