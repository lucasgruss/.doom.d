#+TITLE: Doom modules
#+Author: Lucas Gruss

* Table of content :TOC:
- [[#exwm][EXWM]]
  - [[#packages][Packages]]
  - [[#config][Config]]
  - [[#media-keys][Media keys]]
  - [[#mouse][Mouse]]
  - [[#exwm-randr][EXWM-randr]]
  - [[#exwm-systemtray][EXWM-Systemtray]]
  - [[#exwm-1][EXWM]]
  - [[#exwm-firefox][EXWM-Firefox]]
  - [[#terminal][Terminal]]
- [[#selectrum][Selectrum]]
  - [[#packagesel][packages.el]]
  - [[#configel][config.el]]

* EXWM
** Packages
#+begin_src emacs-lisp :tangle ./modules/personal/exwm/packages.el
(package! xelb :recipe (:no-native-compile t))
(package! exwm :recipe (:no-native-compile t))
(package! exwm-firefox-core)
(package! exwm-firefox-evil)
(package! exwm-firefox
  :recipe
  (:host github
   :repo "ieure/exwm-firefox"))
#+end_src

** Config

The following snippet should go into the file
=/usr/share/xsessions/emacs.desktop= to make EXWM a possible choice in the
display manager.

#+begin_src conf :tangle no
[Desktop Entry]
Name=EXWM
Comment=Emacs is awesome!
Exec=emacs
Type=application
#+end_src

** Media keys

Media keys need to be explicitely bound, as we might not use EXWM in a DE.
#+begin_src emacs-lisp :tangle ./modules/personal/exwm/config.el
(defun my/volume-down ()
  "Lower volume of the computer"
  (interactive)
  (shell-command "~/scripts/volume.sh down"))

(defun my/volume-up ()
  "Increase volume of the computer"
  (interactive)
  (shell-command "~/scripts/volume.sh up"))

(defun my/brightness-down ()
  "Lower brightness of the screen"
  (interactive)
  (shell-command "xbacklight -dec 10"))

(defun my/brightness-up ()
  "Increase brightness of the screen"
  (interactive)
  (shell-command "xbacklight -inc 10"))
#+end_src

** Mouse
#+begin_src emacs-lisp :tangle ./modules/personal/exwm/config.el
;; (defun my/exwm-floating-resize (drag-event)
;;   (interactive "e")
;;   )
(setq! exwm-input-resize-event )
(map! "<mode-line> <double-mouse-3>" #'exwm-floating-toggle-floating)
      ;;"<top-left-corner> <mouse-1>" #'exwm-)

#+end_src

** EXWM-randr

EXWM has built in support for multi-monitor.
#+begin_src emacs-lisp :tangle ./modules/personal/exwm/config.el
(use-package! exwm-randr
  :config
  ;;(setq! exwm-randr-workspace-output-plist '(1 "VGA1"))
  (setq! exwm-randr-workspace-output-plist '(1 "DP2" 2 "DP2"))
  (setq! exwm-randr-screen-change-hook nil)
  (add-hook 'exwm-randr-screen-change-hook
            (lambda ()
              (start-process-shell-command
               "xrandr" nil "xrandr --output DP2 --left-of eDP1")))
               ;;"xrandr" nil "xrandr --output VGA1 --left-of LVDS1")))
  (exwm-randr-enable))
#+end_src

** EXWM-Systemtray

It's nice to have a systray, and there is nothing wrong with exwm-systray, but
since I am using XFCE and the XFCE-panel is just [insert chef's kiss], I don't
use it any longer.

#+begin_src emacs-lisp :tangle ./modules/personal/exwm/config.el
(use-package! exwm-systemtray
  :disabled
  :config
  (setq! exwm-systemtray-height 15)
  ;;exwm-systemtray-icon-gap 3)
  ;;exwm-systemtray-background-color 'black)
  (exwm-systemtray-enable))
#+end_src

** EXWM
EXWM is seriously awesome. Now I don't have to exit emacs *ever* and I get to
configure my window manager with emacs lisp. Life is good.

#+begin_src emacs-lisp :tangle ./modules/personal/exwm/config.el
(use-package! exwm
  :init
  (setq! exwm-firefox-buffer-name "Firefox")
  (map!
   :map exwm-mode-map
   :localleader
   :desc "Toggle mode-line"       "m" #'exwm-layout-toggle-mode-line
   :leader
   (:prefix ("e" . "EXWM")
    :desc "Attach minibuffer"      "a" #'exwm-workspace-attach-minibuffer
    :desc "Detach minibuffer"      "d" #'exwm-workspace-detach-minibuffer
    :desc "Fullscreen"             "f" #'exwm-layout-set-fullscreen
    :desc "Floating hide"          "h" #'exwm-layout-set-fullscreen
    :desc "Release keyboard"       "k" #'exwm-input-release-keyboard
    :desc "Send next key"          "q" #'exwm-input-send-next-key
    :desc "Reset"                  "r" #'exwm-reset
    :desc "Toggle floating layout" "t" #'exwm-floating-toggle-floating
    :desc "Workspace move window"  "w" #'exwm-workspace-move-window))

  :config
  (defun my/exwm-async-run (name)
    "Run a process asynchronously"
    (interactive)
    (start-process name nil name))

  (defun my/run-or-raise-or-dismiss (program program-buffer-name)
    "If no instance of the program is running, launch the program.
If an instance already exists, and its corresponding buffer is
displayed on the screen, move to the buffer. If the buffer is not
visible, switch to the buffer in the current window. Finally, if
the current buffer is already that of the program, bury the
buffer (=minimizing in other WM/DE)"
    ;; check current buffer
    (if (string= (buffer-name) program-buffer-name)
        (bury-buffer)
      ;; either switch to or launch program
      (progn
        (if (get-buffer program-buffer-name)
            (progn
              (if (get-buffer-window program-buffer-name)
                  (select-window (display-buffer program-buffer-name) nil)
                (exwm-workspace-switch-to-buffer program-buffer-name)))
          ;; start program
         (progn
          (my/exwm-async-run program)
          (message (format "Launching %s" program)))))))

  (defun my/run-or-raise-or-dismiss-firefox ()
    (interactive)
    (my/run-or-raise-or-dismiss "firefox" "Firefox")
    (exwm-input--fake-key 'f11))

  (defun my/run-or-raise-or-dismiss-spotify ()
    (interactive)
    (my/run-or-raise-or-dismiss "spotify" "Spotify"))

  (defun my/run-or-raise-or-dismiss-thunderbird ()
    (interactive)
    (my/run-or-raise-or-dismiss "thunderbird" "Thunderbird"))

  (defun my/toggle-line-char-modes ()
    "If on a EXWM buffer, toggle 'line' or 'char'"
    (interactive)
    (if exwm-window-type
        (if (string= exwm--input-mode "line-mode")
            (call-interactively #'exwm-input-release-keyboard) ; switch to char mode
          (call-interactively #'exwm-input-grab-keyboard)))) ; switch to line mode

  (defun my/toggle-panel ()
    (interactive)
    (shell-command "cd && pgrep xfce4-panel && xfce4-panel -q || xfce4-panel &"))

  (defun my/lock-screen ()
    "Lock screen with slock"
    (interactive)
    (start-process "" nil "/usr/local/bin/slock"))

  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
                                        ;(add-hook 'exwm-manage-finish-hook 'exwm-layout-hide-mode-line)

  (setq exwm-input-global-keys
        `(;; EXWM
          ([S-s-backspace] . exwm-workspace-delete)
          ([?\s-f] . exwm-layout-set-fullscreen)
          ([?\s-R] . exwm-reset)
          ([?\s-w] . exwm-workspace-switch)
          ([?\s-W] . exwm-workspace-move-window)
          ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" i)) .
                        (lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i))))
                    (number-sequence 0 9))
          ([?\s-!] . (lambda () (interactive) (exwm-workspace-move-window 1)))
          ([?\s-\"] . (lambda () (interactive) (exwm-workspace-move-window 2)))
          ([?\s-Â£] . (lambda () (interactive) (exwm-workspace-move-window 3)))
          ([?\s-$] . (lambda () (interactive) (exwm-workspace-move-window 4)))
          ([?\s-%] . (lambda () (interactive) (exwm-workspace-move-window 5)))
          ([?\s-^] . (lambda () (interactive) (exwm-workspace-move-window 6)))
          ([?\s-&] . (lambda () (interactive) (exwm-workspace-move-window 7)))
          ([?\s-*] . (lambda () (interactive) (exwm-workspace-move-window 8)))
          ([?\s-\(] . (lambda () (interactive) (exwm-workspace-move-window 9)))
          ([?\s-\)] . (lambda () (interactive) (exwm-workspace-move-window 0)))
          ([?\s-b] . counsel-switch-buffer)
          ([?\s-B] . bury-buffer)
          ([?\s-&] . (lambda (command) (interactive (list (read-shell-command "$ ")))
                       (start-process-shell-command command nil command)))
          ([s-f2]  . my/lock-screen)
          ([?\s-d] . counsel-linux-app)
          ([?\s-i] . my/run-or-raise-or-dismiss-firefox)
          ([?\s-t] . my/run-or-raise-or-dismiss-thunderbird)
          ([?\s-s] . my/run-or-raise-or-dismiss-spotify)
          ([?\s-m] . my/toggle-line-char-modes)
          ([s-return] . +vterm/toggle)
          ([?\s-e] . +eshell/toggle)
          ([s-backspace] . my/kill-this-buffer)
          ([s-escape] . my/kill-this-buffer)
          ([s-,]  . centaur-tabs-backward)
          ([s-.]  . centaur-tabs-forward)
          ([s-<]  . tab-previous)
          ([s->]  . tab-next)
          ;; Everything window
          ([?\s-q] . evil-window-delete)
          ([s-tab]  . windower-switch-to-last-buffer)
          ([?\s-r]  . windower-switch-to-last-buffer)
          ([?\s-\\] . windower-toggle-split)
          ([?\s-o]  . windower-toggle-single)
          ([142606440] . windower-move-border-left) ; M-s-h
          ([142606442] . windower-move-border-below); M-s-j
          ([142606443] . windower-move-border-above); M-s-k
          ([142606444] . windower-move-border-right); M-s-l
          ([?\s-h] . windmove-left)  ([?\s-H] . windower-swap-left)
          ([?\s-j] . windmove-down)  ([?\s-J] . windower-swap-below)
          ([?\s-k] . windmove-up)    ([?\s-K] . windower-swap-above)
          ([?\s-l] . windmove-right) ([?\s-L] . windower-swap-right)
          ;; Media keys
          ([XF86MonBrightnessUp]   . my/brightness-up)
          ([XF86MonBrightnessDown] . my/brightness-down)
          ([XF86AudioRaiseVolume]  . my/volume-up)
          ([XF86AudioLowerVolume]  . my/volume-down))
        exwm-workspace-show-all-buffers t
        exwm-workspace-number 1
        exwm-workspace-minibuffer-position nil
        exwm-workspace-display-echo-area-timeout 1)

  (setq! exwm-manage-configurations
         '(((equal "Whisker Menu" exwm-title)
            ;;floating t
            x 0
            y 0
            width 300
            height 400
            fullscreen nil
            ;;char-mode t
            managed t
            )))

  (push (aref (kbd "<escape>") 0) exwm-input-prefix-keys)
  (push (aref (kbd "<return>") 0) exwm-input-prefix-keys)
  ;; (setq! exwm-input-simulation-keys
  ;;   '(([?\M-h] . [left])
  ;;     ([?\M-l] . [right])
  ;;     ([?\C-k] . [up])
  ;;     ([?\C-j] . [down])))
      ;([?\C-a] . [home])
      ;([?\C-e] . [end])
      ;([?\M-v] . [prior])
      ;([?\C-v] . [next])
      ;([?\C-d] . [delete])
  (exwm-enable)
  ;; relaunch the panel so that it auto-hide correctly
  (shell-command "xfce4-panel --restart"))
  #+end_src

** EXWM-Firefox

With EXWM emulation keys, you can have vi-style keybindings within firefox,
without having to install anything on the browser. Have I mentioned how awesome EXWM
is? My next objective will probably be to bring firefox even closer to emacs by
enabling new tabs within new windows and have emacs handle all windows with iBuffer.

#+begin_src emacs-lisp :tangle ./modules/personal/exwm/config.el
(use-package! exwm-firefox-evil
  :hook ((exwm-manage-finish . exwm-firefox-evil-activate-if-firefox)
         ;; (exwm-manage-finish . my/exwm-firefox-force-fullscreen)
         (exwm-firefox-evil-mode . my/exwm-firefox-hook))
  :config
  (setq exwm-firefox-evil-class-name '("Firefox" "Firefox-esr"))
  (defun exwm-input--on-ButtonPress-line-mode (buffer button-event)
    "Handle button events in line mode.
BUFFER is the `exwm-mode' buffer the event was generated
on. BUTTON-EVENT is the X event converted into an Emacs event.

The return value is used as event_mode to release the original
button event."
    (with-current-buffer buffer
      (let ((read-event (exwm-input--mimic-read-event button-event)))
        (exwm--log "%s" read-event)
        (if (and read-event
                 (exwm-input--event-passthrough-p read-event))
            ;; The event should be forwarded to emacs
            (progn
              (exwm-input--cache-event read-event)
              (exwm-input--unread-event button-event)
              xcb:Allow:ReplayPointer)
          ;; xcb:Allow:SyncPointer)
          ;; The event should be replayed
          xcb:Allow:ReplayPointer))))

  (defun my/exwm-firefox-force-fullscreen ()
    "Send F11 to firefox to always be in full screen.

Whenever you switch to another window and then come back to
firefox, it leaves fullscreen mode."
    (interactive)
    (exwm-input--fake-key 'f11))

  (defun my/exwm-firefox-toggle-tree-tab ()
    "Toggle the tree tab extension"
    (interactive)
    (exwm-input--fake-key 'f1))

  (defun my/exwm-firefox-hook ()
    "Sets firefox how I like it"
    (interactive)
    (when exwm-firefox-evil-mode
      (my/exwm-firefox-toggle-tree-tab)))

  (defun my/exwm-firefox-hint ()
    "Highlights hints on the page."
    (interactive)
    (exwm-input--fake-key 'C-m)
    (exwm-firefox-evil-insert))

  ;; go back to normal mode after pressing return
  (defun exwm-firefox-intercept-next-ret ()
    (interactive)
    (setq-local exwm-firefox-next-ret-normal t))

  (defun exwm-firefox-intercept-return ()
    (interactive)
    (exwm-input--fake-key (aref (kbd "<return>") 0))
    (when (and (boundp 'exwm-firefox-next-ret-normal)
               exwm-firefox-next-ret-normal)
      (exwm-firefox-evil-normal)
      (setq-local exwm-firefox-next-ret-normal nil)))

  (advice-add #'exwm-firefox-core-tab-new :after #'exwm-firefox-intercept-next-ret)
  (advice-add #'my/exwm-firefox-hint :after #'exwm-firefox-intercept-next-ret)
  (advice-add #'exwm-firefox-core-focus-search-bar :after #'exwm-firefox-intercept-next-ret)
  (advice-add #'exwm-firefox-core-quick-find :after #'exwm-firefox-intercept-next-ret)


  (define-key! 'normal exwm-firefox-evil-mode-map
    "f" #'my/exwm-firefox-hint
    "F" #'my/exwm-firefox-force-fullscreen
    "T" #'my/exwm-firefox-toggle-tree-tab
    "q" #'exwm-input-send-next-key
    "<return>" #'exwm-firefox-intercept-return)

  (define-key! 'insert exwm-mode-map
    "<return>" #'exwm-firefox-intercept-return
    "C-h" #'exwm-firefox-core-left
    "C-j" #'exwm-firefox-core-down
    "C-k" #'exwm-firefox-core-up
    "C-l" #'exwm-firefox-core-right)
  )

(use-package! exwm-firefox
  :after exwm-firefox-evil
  :config
  ;; I have different keybinding in firefox for tabdetach-attach : M-S-t
  (defun my/exwm-firefox-attach ()
    "Attach the current tab into its parent window.

   This requires the tabdetach extension to work."
    (interactive)
    (exwm-input--fake-key ?\M-\S-T))

  (define-key! 'normal exwm-firefox-evil-mode-map
    "A" #'my/exwm-firefox-attach
    "D" #'exwm-firefox-split-detach
    "M" #'exwm-firefox-merge)
  ;; I don't like renaming the name of the firefox window
  (remove-hook 'exwm-update-title-hook 'exwm-firefox--update-title))
#+end_src

** Tab-line fix
#+begin_src emacs-lisp :tangle ./modules/personal/exwm/config.el
(after! exwm-layout
  (progn
    (defun exwm-layout--show (id &optional window)
      "Show window ID exactly fit in the Emacs window WINDOW."
      (exwm--log "Show #x%x in %s" id window)
      (let* ((edges (window-inside-absolute-pixel-edges window))
             (x (pop edges))
             (y (pop edges))
             (width (- (pop edges) x))
             (height (- (pop edges) y))
             frame-x frame-y frame-width frame-height)
        (with-current-buffer (exwm--id->buffer id)
          (when exwm--floating-frame
            (setq frame-width (frame-pixel-width exwm--floating-frame)
                  frame-height (+ (frame-pixel-height exwm--floating-frame)
                                  ;; Use `frame-outer-height' in the future.
                                  exwm-workspace--frame-y-offset))
            (when exwm--floating-frame-position
              (setq frame-x (elt exwm--floating-frame-position 0)
                    frame-y (elt exwm--floating-frame-position 1)
                    x (+ x frame-x (- exwm-layout--floating-hidden-position))
                    y (+ y frame-y (- exwm-layout--floating-hidden-position)))
              (setq exwm--floating-frame-position nil))
            (exwm--set-geometry (frame-parameter exwm--floating-frame
                                                 'exwm-container)
                                frame-x frame-y frame-width frame-height))
          (when (exwm-layout--fullscreen-p)
            (with-slots ((x* x)
                         (y* y)
                         (width* width)
                         (height* height))
                (exwm-workspace--get-geometry exwm--frame)
              (setq x x*
                    y y*
                    width width*
                    height height*)))
          ;; edited here
          (when
              (and (not (bound-and-true-p centaur-tabs-local-mode))
                   (or (bound-and-true-p centaur-tabs-mode)
                       (bound-and-true-p tab-line-mode)))
            (setq y (+ y centaur-tabs-height)))
          ;; edited here
          (exwm--set-geometry id x y width height)
          (xcb:+request exwm--connection (make-instance 'xcb:MapWindow :window id))
          (exwm-layout--set-state id xcb:icccm:WM_STATE:NormalState)
          (setq exwm--ewmh-state
                (delq xcb:Atom:_NET_WM_STATE_HIDDEN exwm--ewmh-state))
          (exwm-layout--set-ewmh-state id)
          (exwm-layout--auto-iconify)))
      (xcb:flush exwm--connection))))
#+end_src

** Terminal

Ansi-term, eshell and vterm are pretty decent, but EXWM makes it possible to use
an /actual/ terminal emulator, which usually works better for some programs
(curses for instance).

#+begin_src emacs-lisp :tangle no
(setq exwm-x-terminal-emulator "gnome-terminal")
(defun my/invoke-x-terminal-emulator ()
  "If external terminal emulator exists, switch to its buffer or
else launch it."
  (interactive)
  (if (string= (buffer-name) "Gnome-terminal")
      (bury-buffer)
    (if (get-buffer "Gnome-terminal")
        (exwm-workspace-switch-to-buffer "Gnome-terminal")
      (my/exwm-async-run exwm-x-terminal-emulator))))

(set-popup-rules!
  '(("Gnome-terminal"
     :vslot -5 :size 0.35 :select t :modeline t :quit nil)))

(map! "<s-return>" #'my/invoke-x-terminal-emulator)
#+end_src

* Selectrum
** packages.el

#+begin_src emacs-lisp :tangle ./modules/personal/selectrum/packages.el
(package! selectrum
  :recipe
  (:host github :repo "raxod502/selectrum"))
(package! selectrum-prescient
  :recipe
  (:host github
   :repo "raxod502/prescient.el"
   :files ("selectrum-prescient.el")))
#+end_src

** config.el

#+begin_src emacs-lisp :tangle ./modules/personal/selectrum/config.el
(use-package! selectrum
  :config
  (map! :map selectrum-minibuffer-map
        "C-j" #'next-line
        "C-k" #'previous-line
        "C-l" #'selectrum-insert-current-candidate
        "<backspace>" #'doom/delete-backward-word
        "<ESC>" #'exit-minibuffer)
  (selectrum-mode +1))

(use-package! selectrum-prescient
  :after selectrum
  :config
  (selectrum-prescient-mode +1))
#+end_src
